<?xml version="1.0" encoding="utf-8"?>
<mx:TextArea xmlns:fx="http://ns.adobe.com/mxml/2009" 
			xmlns:s="library://ns.adobe.com/flex/spark" 
			xmlns:mx="library://ns.adobe.com/flex/mx"
			keyFocusChange="onKeyFocusChange(event)"
			creationComplete="onCreationComplete(event)"
			>
	<fx:Script>
		<![CDATA[
			import com.adobe.linguistics.spelling.SpellUI;
			
			import mx.controls.textClasses.TextRange;
			import mx.core.mx_internal;
			import mx.events.FlexEvent;
			use namespace mx_internal;
			
			private static const UNDO_BUFFER_SIZE:uint = 30;
			private static const SHIFT_DIRECTION_LEFT:String = "LEFT";
			private static const SHIFT_DIRECTION_RIGHT:String = "RIGHT";
			private static const SHIFT_BLOCKQUOTE:String = "BLOCKQUOTE";
			private static const SHIFT_CODEBLOCK:String = "CODEBLOCK";
			
			private var _undoStack:Vector.<String> = new Vector.<String>();
			private var _undoNext:String = null;
			private var _fullPath:String;
			private var _isModified:Boolean = false;
			private var _updateInterval:uint;
			private var _isReference:Boolean = false;
			
			protected function onCreationComplete(event:FlexEvent):void
			{				
				SpellUI.enableSpelling(this, "en_US");
			}
			
			protected function onKeyFocusChange(event:FocusEvent):void
			{
				event.preventDefault();
				var range:TextRange = new TextRange(this, true);
				if (range.beginIndex != range.endIndex) {
					if (event.shiftKey) {
						this.shiftLeft();
					} else {
						this.shiftRight();
					}
				} else {
					this.textField.replaceSelectedText("    ");
				}
			}
			
			private function getCurrentShiftChunk():String {
				var tmp:int;
				var range:TextRange = new TextRange(this, true);
				var beginChunk:int = ((tmp = this.text.substring(0, range.beginIndex > 0 ? range.beginIndex : 0).lastIndexOf("\r")) == -1 ? 0 : tmp+1);
				var endChunk:int = ((tmp = this.text.substring(range.endIndex).indexOf("\r")) == -1 ? this.text.length : tmp + range.endIndex);
				return this.text.substring(beginChunk, endChunk);
			}
			
			private function _shiftText(direction:String):void {
				var tmp:int;
				var range:TextRange = new TextRange(this, true);
				var beginChunk:int = ((tmp = this.text.substring(0, range.beginIndex).lastIndexOf("\r")) == -1 ? 0 : tmp+1);
				var endChunk:int = ((tmp = this.text.substring(range.endIndex).indexOf("\r")) == -1 ? this.text.length : tmp + range.endIndex);
				var shiftChunk:String = this.text.substring(beginChunk, endChunk);
				while (shiftChunk.length > 0 && shiftChunk.charAt(0).search(/[\r\n]/) != -1) {
					if (shiftChunk.length == 1) {
						shiftChunk = "";
						beginChunk++;
						break;
					}
					shiftChunk = shiftChunk.substr(1);
					beginChunk++;
				}
				while (shiftChunk.length > 0 && shiftChunk.charAt(shiftChunk.length-1).search(/[\r\n]/) != -1) {
					if (shiftChunk.length == 1) {
						shiftChunk = "";
						endChunk--;
						break;
					}
					shiftChunk = shiftChunk.substr(0, shiftChunk.length-1);
					endChunk--;
				}
				var lines:Array = shiftChunk.split(/[\r\n]/);
				var pattern:RegExp = /^\s{1,4}/;
				
				shiftChunk = "";
				for (var i:uint = 0; i < lines.length; i++) {
					if (direction == GonzoTextArea.SHIFT_DIRECTION_LEFT) {
						shiftChunk += lines[i].replace(pattern, "") + (i+1 == lines.length ? "" : "\n");
					} else if (direction == GonzoTextArea.SHIFT_DIRECTION_RIGHT || direction == GonzoTextArea.SHIFT_CODEBLOCK) {
						shiftChunk += "    " + lines[i] + (i+1 == lines.length ? "" : "\n");
					} else if (direction == GonzoTextArea.SHIFT_BLOCKQUOTE) {
						shiftChunk += "> " + lines[i] + (i+1 == lines.length ? "" : "\n");
					} 
				}
				
				this.setSelection(beginChunk, endChunk);
				this.validateNow();
				range = new TextRange(this, true);
				trace("------------------------\n" + range.text);
				if (direction == GonzoTextArea.SHIFT_BLOCKQUOTE) {
					var before:String = this.text.substring(0, range.beginIndex);
					lines = before.split(/[\r\n]/);
					var prefix:String = "", suffix:String = "";
					
//					trace("BEFORE\n------");
//					for (var k:uint = 0; k < lines.length; k++) {
//						trace("'" + lines[k] + "'");
//					}
					
					if (lines.length == 0) {
						prefix = "";
					} else if (lines.length == 1 && (lines[0] as String).search(/[\r\n]/) != -1) {
						prefix = "";
					} else if (lines.length > 1 && 
						       lines[lines.length-1] == "" &&
							       (lines[lines.length-2] == "" || 
								   (lines[lines.length-2] as String).search(/^>\s*$/) != -1)
							  ) {
						prefix = "";
					} else {
						prefix = ">\n";
					}
					
					shiftChunk = prefix + shiftChunk + suffix;
				}
				range.text = shiftChunk;
				
				this.dispatchEvent(new Event(Event.CHANGE));
			}
			
			public function shiftRight():void {
				_shiftText(GonzoTextArea.SHIFT_DIRECTION_RIGHT);
			}
			
			public function shiftLeft():void {
				_shiftText(GonzoTextArea.SHIFT_DIRECTION_LEFT);
			}
			
			public function shiftBlockquote():void {
				_shiftText(GonzoTextArea.SHIFT_BLOCKQUOTE);
			}
			
			public function shiftCodeBlock():void {
				_shiftText(GonzoTextArea.SHIFT_CODEBLOCK);
			}
			
			public function getCaretIndex():int {
				return this.getTextField().caretIndex;
			}
			
			public function updateEditor():void {
				clearInterval(this.updateInterval);
				if (!this.isReference) {
					this.pushUndo(this.text);
				}
				this.dispatchEvent(new Event(Event.COMPLETE));	
			}
			
			public function pushUndo(string:String):void {
				while (_undoStack.length >= UNDO_BUFFER_SIZE) {
					_undoStack.pop();
				} 
				
				if (_undoNext != string) {
					if (_undoNext != null) {
						_undoStack.unshift(_undoNext);
					}
					_undoNext = string;
				}
			}
			
			public function popUndo():String {
				var undo:String;
				if (_undoStack.length > 0) {
					undo = _undoStack.shift();
					_undoNext = undo;
				} else {
					undo = null;
				}
				
				return undo;
			}
			
			////////// Helper Functions //////////
			public function printUndoStack():void {
				for (var i:uint = 0; i < _undoStack.length; i++) {
					trace("STACK[" + i.toString() + "]:" + _undoStack[i]);
				}
				trace("NEXT:" + _undoNext);
				trace("");
			}
			
			////////// Getters and Setters //////////
			public function get isReference():Boolean
			{
				return _isReference;
			}
			
			public function set isReference(value:Boolean):void
			{
				_isReference = value;
			}
			
			public function get filename():String
			{
				return GonzoUtils.getFilenameFromPath(_fullPath);
			}
			
			public function get fullPath():String
			{
				return _fullPath;
			}
			
			public function set fullPath(value:String):void
			{
				_fullPath = value;
			}
			
			public function get isModified():Boolean
			{
				return _isModified;
			}
			
			public function set isModified(value:Boolean):void
			{
				_isModified = value;
			}
			
			public function get updateInterval():uint
			{
				return _updateInterval;
			}
			
			public function set updateInterval(value:uint):void
			{
				_updateInterval = value;
			}
		]]>
	</fx:Script>
</mx:TextArea>
